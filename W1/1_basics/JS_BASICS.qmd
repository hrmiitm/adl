---
title: "Javascript Basics"
subtitle: "Efficiency, Array, String, Object, Map, Set"
format:
  html:
    toc: true
    toc-location: right
    toc-depth: 3
    smooth-scroll: true

    # Code formatting
    code-copy: true
    code-fold: show
    code-line-numbers: true
#     code-overflow: wrap
    highlight-style: dracula

---

<details closed>
<summary><h1 style="display: inline;">Efficiency & Complexity Analysis</h1></summary>

## Algorithm Efficiency

1. Time Efficiency  
2. Space Efficiency

### Asymptotic Analysis

Focuse on **Growth rate wrt input size**. Below c,c1,c2 are some +ve constant.

1. **Big O - Upper Bound / Worst Case**

`f(n) = O(g(n))` if `f(n) <= c.g(n)` for all n>=n1

2. **Big Omega - Lower Bound**

`f(n) = Ω(g(n))` if `f(n) >= c.g(n)` for all n>=n1

3. **Big Theta - Tight Bound**

`f(n) = Θ(g(n))` if `c1.g(n) <= f(n) <= c2.g(n)` for all n>=n1


</details>

<details closed>
<summary><h1 style="display: inline;">Array</h1></summary>

## Array

JavaScript arrays are **zero-indexed, mutable, dynamic collections.** Arrays indexing in javascript are forgiving in nature.

```javascript
let arr = ['hi', 'how']

arr[5] = 'are'

console.log(arr)

for(let i=0; i<=7; i++) {
    console.log(arr[i])
}
```

**Output**

```
[ 'hi', 'how', <3 empty items>, 'are' ]
hi
how
undefined
undefined
undefined
are
undefined
undefined
```

**Note**

1. `arr.length` will give you 6  
2. Not recommended to assign any value like this, it is allowed since they are internally object, but if they are used means index value are getting random then array optimization feature will be turned off.  

### Array Operations

In JS arrays has one property 'length' i.e.  `myarr.length` return whole number.  

**Note**

`arr = ['hi', 'how', 'are', 'you']`

1. `arr[-1]` will give value `undefined`  
2. `arr.at(-1)` will give value `'you'`  
3. `arr.slice(1, 3)` will give shallow copy of arr as `['how', 'are']`  
4. `arr.splice(1,3, 1,2)` will start from index=1 and will delete 3 items and then insert 1 and then 2.  
5. `array.splice(start, deleteCount, item1, item2, ...)` it modify the original array and **return deleted items as array**

### Front and Back

```javascript
let arr = ['hi', 'how']

// STACK
x = arr.push('**')  // [ 'hi', 'how', '**' ]
y = arr.pop()

// Queue
p = arr.unshift('**') // [ 'hi', 'how', '**' ]
q = arr.shift()

console.log(arr);
console.log(x,y)
console.log(p,q)
```

**Output**

```
[ 'hi', 'how' ]
3 **
3 **
```

### Iterate in array

```javascript
let arr = ['hi', 'how', 'are', 'you']


for(let ele in arr) { console.log(ele) }

for(let ele of arr) { console.log(ele) }

arr.forEach( (ele, index, myarr) => {console.log(ele, index, myarr)})
```

**Output**

```
0
1
2
3
hi
how
are
you
hi 0 [ 'hi', 'how', 'are', 'you' ]
how 1 [ 'hi', 'how', 'are', 'you' ]
are 2 [ 'hi', 'how', 'are', 'you' ]
you 3 [ 'hi', 'how', 'are', 'you' ]
```

**Note**

1. `for in` give `index` or `key` in array/object

**Key Value type iterations**

```javascript
let arr = ['hi', 'how', 'are', 'you']
let myobj = {name: "hrm", age: 23}

for(let [k, v] of arr.entries()) { console.log(`${k}: ${v}`) }
for(let [k, v] of Object.entries(arr)) { console.log(`${k}: ${v}`) }
for(let [k, v] of Object.entries(myobj)) { console.log(`${k}: ${v}`) }
```

**Output**
```
0: hi
1: how
2: are
3: you
0: hi
1: how
2: are
3: you
name: hrm
age: 23
```

</details>

<details closed>
<summary><h1 style="display: inline;">String</h1></summary>

## String

Strings are **immutable**, while arrays are mutable

```javascript
let mystr = "hello world"
let st2 = 'hi'

console.log(mystr.length)
console.log(mystr[1])
console.log(mystr[-1])
console.log(mystr.at(-1))
console.log(mystr.charAt(-1))
console.log(mystr.toUpperCase())
console.log(mystr + st2)

for(let ele of st2) {console.log(ele)}
for(let [k, v] of Object.entries(st2)) {console.log(`${k}: ${v}`)}
```

**Output**

```
11
e
undefined
d

HELLO WORLD
hello worldhi
h
i
0: h
1: i
```



</details>


<details closed>
<summary><h1 style="display: inline;">Object and Map</h1></summary>

## Object

**Objects** are collections of key-value pairs where keys must be **strings** or **symbols**.

### Creating Objects

```javascript
// Literal syntax
const mysym = Symbol("k1")
const user = { name: "John", age: 25, [mysym]: 'v1' };

// Constructor
const obj = new Object({ city: "Mumbai" });

console.log(user)
console.log(user[mysym]) // frequentrly asked question

/* Output
{ name: 'John', age: 25, [Symbol(k1)]: 'v1' }
v1
*/
```


### When to Use Objects

- Records with known string keys  
- **JSON serialization needed**
- Property access syntax (`obj.prop`)  
- Working with existing APIs  


## Map

**Maps** are collections where keys can be any data type and maintain insertion order.

### Creating Maps

```javascript
// Empty Map
const map = new Map();

// With initial values
const fruits = new Map([["apple", 100], ["banana", 50]]);

// Using methods
map.set("name", "Alice");
map.set(1, "numeric key");
```



### Essential Map Methods

- `set(key, value)` - Add/update  
- `get(key)` - Retrieve value  
- `has(key)` - Check existence  
- `delete(key)` - Remove pair  
- `size` - Get count  

### When to Use Maps

- Non-string keys needed  
- Frequent additions/deletions  
- Maintain insertion order  
- **Unknown runtime size**  


::: {.callout-note collapse=true}

## Key Differences: Map vs Object

| Feature | Map | Object |
| :-- | :-- | :-- |
| **Key Types** | Any data type (objects, functions, primitives) | Only strings and symbols |
| **Size** | `map.size` property | Manual calculation required |
| **Iteration** | Directly iterable with `for...of` | Requires `Object.keys()` or similar |
| **Order** | Maintains insertion order | No guaranteed order |
| **Performance** | Better for frequent additions/deletions | Better for record-like structures |
| **JSON Support** | No direct JSON support | Direct JSON support |
| **Default Keys** | No default keys | Inherits prototype properties |

:::

</details>


<details closed>
<summary><h1 style="display: inline;">Set</h1></summary>

## Set

**Set** is a collection of unique values of any data type - no duplicates are allowed. Each value can only occur once, whether primitive values or object references.

### Creating Sets

```javascript
// Empty Set
const mySet = new Set();

// From array (removes duplicates)
const letters = new Set(["a", "b", "c", "a"]); // Set {"a", "b", "c"}

// From string (unique characters)
const chars = new Set("hello"); // Set {"h", "e", "l", "o"}
```


### Essential Set Methods

| Method | Description | Example |
| :-- | :-- | :-- |
| `add(value)` | Adds new element | `set.add("apple")` |
| `has(value)` | Checks if value exists | `set.has("apple")` |
| `delete(value)` | Removes element | `set.delete("apple")` |
| `clear()` | Removes all elements | `set.clear()` |
| `size` | Returns number of elements | `set.size` |


## Iteration Methods

```javascript
const mySet = new Set([1, 2, 3]);

// For...of loop
for (const value of mySet) {
  console.log(value);
}

// forEach method
mySet.forEach(value => console.log(value));

// Values iterator
for (const value of mySet.values()) {
  console.log(value);
}
```

</details>