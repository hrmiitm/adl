---
title: "Selection & Insertion Sort"
format:
  html:
    toc: true
    toc-location: right
    toc-depth: 3
    smooth-scroll: true

    # Code formatting
    code-copy: true
    code-fold: show
    code-line-numbers: true
    highlight-style: dracula
---

<details closed>
<summary><h1 style="display: inline;">Selection & Insertion Sort</h1></summary>

# Selection & Insertion Sort

* **Selection Sort**: Select min element in whole array(unsorted), then place at begining.
* **Insertion Sort**: Pick first element from unsorted part and place it in corrcet place.

::: {.callout-note collapse="false"}
Selection sort is preferred when `write operations` are costly, as it makes only `n–1 writes`, unlike insertion sort which may make up to `n²`. 

Insertion sort is better for `nearly sorted data`, where the order (ascending/descending) is known.
:::

## Implementation

### Selection Sort

::: {.panel-tabset group="language"}
### Javascript

``` {.javascript}
let arr = [3, 6, 9, 7, 2, 3, 1];
let n = arr.length;

for (let i = 0; i < n - 1; i++) {
    let min_index = i;
    for (let j = i + 1; j < n; j++) {
        if (arr[j] < arr[min_index]) {
            min_index = j;
        }
    }
    [arr[i], arr[min_index]] = [arr[min_index], arr[i]];
}

console.log(arr);  // Output: [1, 2, 3, 3, 6, 7, 9]
```

### Python

``` {.python}
arr = [3, 6, 9, 7, 2, 3, 1]
n = len(arr) # 7

for i in range(n):

    # Find min element/index
    min_index = i
    for j in range(i+1, n):
        if arr[j] < arr[min_index]:
            min_index = j

    # Swap with last element of sorted part
    (arr[i], arr[min_index]) = (arr[min_index], arr[i])
print(arr)  # [1, 2, 3, 3, 6, 7, 9]
```

:::

### Insertion Sort

::: {.panel-tabset group="language"}
### Javascript

``` {.javascript}
let arr = [3, 6, 9, 7, 2, 3, 1];
let n = arr.length;

for(let i = 1; i < n; i++) {
    let key = arr[i];
    let j = i - 1;

    while(j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }

    arr[j + 1] = key;
}

console.log(arr);  // Output: [1, 2, 3, 3, 6, 7, 9]
``` 

### Python

``` {.python}
arr = [3, 6, 9, 7, 2, 3, 1]
n = len(arr) # 7

for i in range(n):
    key = arr[i]
    j = i-1

    while(j>=0 and arr[j] > key):
        arr[j+1] = arr[j]
        j -= 1

    arr[j+1] = key

print(arr) # [1, 2, 3, 3, 6, 7, 9]
```


:::


## Key Differences

| Aspect | Selection Sort | Insertion Sort |
| :-- | :-- | :-- |
| **Time Complexity** | O(n²) always | O(n) in bestcase, worst-O(n²) |
| **Space Complexity** | O(1) | O(1) |
| **Stability** | Not stable | Stable |
| **Adaptivity** | Not adaptive | Adaptive |
| **Swaps** | O(n) always | 0 to O(n²) |


</details>

<details closed>
<summary><h1 style="display: inline;">Questions</h1></summary>

# Interview Questions \& Answers

### **Q1**: When would you choose Insertion Sort over Selection Sort?

**Answer:** When data is nearly sorted or small datasets. Insertion sort has O(n) best-case complexity and is adaptive, while Selection sort is always O(n²).

### **Q2**: Are these algorithms stable?

**Answer:** Insertion sort is stable (maintains relative order of equal elements). Selection sort is not stable in its basic implementation.

### **Q3**: Which algorithm makes fewer swaps?

**Answer:** Selection sort makes exactly n-1 swaps, while insertion sort can make up to O(n²) swaps in worst case.

</details>