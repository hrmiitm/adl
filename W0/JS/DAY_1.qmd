---
title: "Day-1"
subtitle: "Variables And Conditionals"
format:
  html:
    toc: true
    toc-location: right
    toc-depth: 3
    smooth-scroll: true

    # Code formatting
    code-copy: true
    code-line-numbers: true
#     code-overflow: wrap
    highlight-style: dracula

---

<details open>
<summary><h1 style="display: inline;">JavaScript Core Concepts - Quick Notes</h1></summary>


## **1. Variables: var/let/const**

**let const are Introduced in ES6 (ECMAScript 2015)**

Var --> Function/Global Scope  
let, const --> Block Scope

**All are hoisted**, but **only var is initialized as `undefined`** at the top of its scope. let and const exist in a `temporal dead zone` until their declaration line is reached.

```javascript
// var - avoid using
var x = 1;
var x = 2;  // OK - can redeclare/assigned

// let - for variables that change
let y = 1;
y = 2;      // OK - can reassign
// let y = 3;  // Error

// const - for constants
const z = 1;    // must be initialized
// z = 2;      // Error 
// const w;    // Error 
```

::: {.callout-tip collapse="true"}
## Problem with `var`

1. **Function-scoped, not block-scoped**  
   - Variables declared with `var` are visible outside the block (`if`, `for`, etc.), which often caused bugs.

```javascript
// Using var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log("var:", i), 1000);
}
// Output: var: 3, var: 3, var: 3   (unexpected!)

// Using let
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log("let:", j), 1000);
}
// Output: let: 0, let: 1, let: 2   (expected!)
```


2. **Hoisting with undefined**  
    - var declarations are hoisted (moved to the top of scope), but initialized with undefined. This sometimes leads to unexpected behavior.
:::


::: {.callout-note collapse="true"}

## What Does "Hoisted" Mean in JavaScript?

Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their scope (either the function or the global scope) before the code runs. This means you can use certain variables or functions before you actually write their declaration in the code.

```javascript
console.log(a); // undefined
var a = 5;
console.log(a); // 5
```

```javascript
console.log(b); // ReferenceError
let b = 10;
```

With `let` and `const`, the variable is hoisted to the top of its block, but not initialized. If you try to use it before its declaration, you get a ReferenceError because it's in the **Temporal Dead Zone (TDZ)**

:::

::: {.callout-tip collapse="true"}

## What to use?

Use `const` mostly.

:::


## **2. Data Types**

### **7 Primitive Types:**

```javascript
let name = "John";           // string
let age = 25;                // number --> 2^53-1
let isActive = true;         // boolean
let data = null;             // null (intentionally empty)
let value;                   // undefined (declared but not assigned)
let id = Symbol("id");       // symbol
let bigNum = 123n;           // bigint --> only Integer(till memory)
```

::: {.callout-tip collapse="true"}

## typeof null; typeof undefined

Type of `null` is `object`, while type of `undefined` is `undefined`.  

`null` type as `object` was a bug / design mistake in the original implementation, but it became part of the language.

:::


### **Reference Types:**

```javascript
let person = {name: "John"}; // object
let numbers = [1, 2, 3];     // array
let greet = function(){};    // function
```


## **3. Variable Naming Rules**

**✅ Valid:**

```javascript
let myName;        // camelCase (preferred)
let _private;      // underscore prefix
let $element;      // dollar sign
let age21;         // numbers (not at start)
let firstName;     // descriptive names
```

**❌ Invalid:**

```javascript
let 2name;         // cannot start with number
let my-name;       // no hyphens
let class;         // reserved keyword
let my name;       // no spaces
```


## **4. Comparison Operators**

### **Equality Comparison:**

```javascript
let a = 5;
let b = "5";

// Loose equality (with type coercion)
console.log(a == b);    // true (converts types)
console.log(a != b);    // false

// Strict equality (no type coercion)
console.log(a === b);   // false (different types)
console.log(a !== b);   // true
```

**Rule:** Always use `===` and `!==` to avoid unexpected results.



## **5. Type Conversion**

1. `Number(x)`  
        - Booleans true, false --> 1,0  
        - null --> 0  
        - undefined, '33abc' --> `Nan`

2. `Boolean(x)`  
        - 1, 0 --> true, false  
        - "" --> false  
        - "0" --> true  

3. `String(x)`

### String +-*/ Number

1. `+` : always do string concat `"5" + 5` or `5 + 5 + "5"` will give 55 and 105.  
2. `- * / % **` : strings converted to numbers

**Note**: booleans are converted to numbers and `null` --> `0` but `undefined` --> `NaN`

```javascript
> null > 0
false
> null == 0
false
> null >= 0
true
```

On equality, `Type Coercion` happend with relational operators, it change `null` to `0`, causes it to `true`.

While for loose equality javascript has `special rule that null can be equal to null and undefined only`.




## **Key Takeaways:**

1. **Use `const` by default**, `let` when reassignment needed, avoid `var`  
2. **Always use `===` and `!==`** for comparisons  
3. **JavaScript uses braces `{}`**, Python uses indentation  
4. **JavaScript has both loose and strict equality**, Python only has strict  
5. **Both languages are dynamically typed** and case-sensitive  
6. For `null` on loose equality javascript has `special rule that null can be equal to null and undefined only`.

</details>
